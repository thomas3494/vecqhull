\section{Preliminaries}

We review some factors that are relevant to performance on a Central Processing
Units (\textit{CPU}).

\subsection{Branching}

Whenever a CPU encounters a conditional jump \textemdash{:~generated by 
if statements and loops in high level languages~\textemdash{} it will guess 
whether to jump or not and start executing. This is also called branching.

This mechanism makes branching practically free if the correct guesses are made.
If not, the CPU must make an expensive recovery. 

\subsection{Vectorisation}

A \textit{vector} or \textit{SIMD} instruction is one that operates on
multiple primitive types (such as integers or floating point numbers) at
the same time. The number of elements is called the \textit{vector width},
and is typically between $2$ and $8$ elements.

Such instructions can be used to do multiple arithmetic operations such as
\texttt{a[0] = b[0] + c[0]; a[1] = b[1] + c[1];} in one instruction, but
also data-movement such as 
\texttt{a[0] = flag[0] ? b[0] : c[0]; a[1] = flag[1] ? b[1] : c[1];}.
This reduces the number of instructions necessary, and can be used to
eliminate branches.

\subsection{Memory Hierarchy and Multithreading}

The speed at which we can do a computation depends on how quickly we can
execute instructions, and on how quickly we can get the necessary data loaded
in registers. We call applications limited by the former \textit{compute-bound},
and applications limited by the latter \textit{memory-bound}.

Random Access Memory (\textit{RAM}) is a seperate from the CPU. The bus
connecting the CPU to RAM is shared by all cores. So while using more cores
linearly increases the computational power available, it does not increase
the available bandwidth. This can turn problems that are compute-bound on
one core memory-bound when using all available cores.

Note that this only holds for a single physical CPU. It is possible to setup
systems with multiple physical CPUs that look like a single CPU from the
programmer's perspective. In that case, using cores from the different CPUs
does increase the available bandwidth.

\iffalse
\subsection{Numerical Analysis}

Accuracy is an important part in engineering a numerical algorithm.


\subsubsection{Floating Point Numbers and Errors}

\subsubsection{Numerical Stability}

Input of scientific algorithms is rarely exact. It can be perturbed by roundoff
errors, but also simply by inaccurate physical measurements. Ideally, this does
not affect the result too much. Let $x$ is the input of an algorithm and 
$f(x)$ the output. We may have a perturbed input $\hat{x}$ and perturbed output
$\hat{f(x)}$. The backward error is ...


\fi
