\section{Introduction}

The convex hull of a set of points in $\mathbb{R}^2$, can be intuitively 
understood as follows: Put a nail in a piece of wood at each point. Then span 
an elastic band around these nails. The resulting polygon is the convex hull of 
the points.

This is a fundamental algorithm in Computational Geometry with applications
in .... 

To be more precise, a convex combination of points $x_1, \cdots, x_n$ is a 
weighted average $\lambda_1 \cdot x_1 + \cdots \lambda_n \cdot x_n$, 
$\lambda_i \geq 0, \sum_{i = 1}^n \lambda_i = 1$. A set that is closed under
taking convex combinations is called convex. The convex hull of a set $X$ is
the set of all its convex combinations and denoted with $CH(X)$. For $X$
a finite set, the convex hull is a polygon with vertices in $X$.

A polygon is determined by its vertices and edges, which we can efficiently
store by listing the vertices in (counter-)clockwise order. The edges are given 
by adjacent vertices.

Computing this list is the convex hull problem. There exist many algorithms for 
this \cite{}, of which we find Quickhull to be the fastest (see
Section~\ref{sec:perf}). This algorithm resembles Quicksort in that
it recursively splits the points into two sets. Unlike Quicksort however,
more points than just the pivot may be discarded. Moreover, we are not
free to choose the pivot, which turns out to make parallelisation challenging.
Nonetheless, we can adept recent insights from the sorting community to engineer
a fast Quickhull implementation for shared memory computers.

We make the following contributions.

\begin{itemize}
    \item We present a vectorized algorithm for extracting two disjoint
          subsets in-place.
    \item We parallelise this algorithm in a bandwidth-friendly manner.
    \item We evaluate the performance on two different platforms. 
\end{itemize}
